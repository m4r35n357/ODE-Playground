# Taylor Series Method in GNU bc - shared functions
#
#  (c) 2018-2025 m4r35n357@gmail.com (Ian Smith), for licencing see the LICENCE file

define void output (x, y, z, t) { print x, " ", y, " ", z, " ", t, " _ _ _ 0.0\n" }

define horner (n, j[], h) {
    auto i, s
    for (i = n; i >= 0; i--) s = s * h + j[i]
    return s
}
 
define const (v, k) {
    if (k == 0) return v
    return 0.0
}

define abs (u[], k) {
    if (u[0] > 0) return u[k]
    if (u[0] < 0) return - u[k]
    return 1.0 / 0.0
}
 
define mul (u[], v[], k) {
    auto j, p
    for (j = 0; j <= k; j++) p += u[j] * v[k - j]
    return p
}
 
define exp (exp[], u[], k) {
    auto j, e
    if (k == 0) return e(u[k])
    for (j = 0; j < k; j++) e += exp[j] * (k - j) * u[k - j]
    return e / k
}

define sin (cos[], u[], k) {
    auto j, s
    if (k == 0) return s(u[k])
    for (j = 0; j < k; j++) s += cos[j] * (k - j) * u[k - j]
    return s / k
}

define cos (sin[], u[], k) {
    auto j, c
    if (k == 0) return c(u[k])
    for (j = 0; j < k; j++) c += sin[j] * (k - j) * u[k - j]
    return - c / k
}
 
define tanh (sech2[], u[], k) {
    auto j, th
    if (k == 0) return (e(u[k]) - e(-u[k])) / (e(u[k]) + e(-u[k]))
    for (j = 0; j < k; j++) th += sech2[j] * (k - j) * u[k - j]
    return th / k
}

define sech2 (tanh[], u[], k) {
    auto j, sh2
    if (k == 0) return 1.0 - (tanh[k] * tanh[k])
    for (j = 0; j < k; j++) sh2 += tanh[j] * (k - j) * tanh[k - j]
    return - 2.0 * sh2 / k
}
