# Taylor Series Method in GNU bc - shared functions
#
#  (c) 2018-2025 m4r35n357@gmail.com (Ian Smith), for licencing see the LICENCE file

define void output (x, y, z, t) { print x, " ", y, " ", z, " ", t, " _ _ _ 0.0\n" }

define horner (u[], n, h) {
    auto i, s
    for (i = n; i >= 0; i--) s = s * h + u[i]
    return s
}
 
define tsm (n, h, steps) {
    auto step
    output(x[0], y[0], z[0], 0)
    for (step = 1; step <= steps; step++) {
        for (k = 0; k < n; k++) {
            x[k + 1] = ode_x() / (k + 1)
            y[k + 1] = ode_y() / (k + 1)
            z[k + 1] = ode_z() / (k + 1)
        }
        x[0] = horner(x[], n, h)
        y[0] = horner(y[], n, h)
        z[0] = horner(z[], n, h)
        output(x[0], y[0], z[0], h * step)
    }
}

define const (v) {
    if (k == 0) return v
    return 0
}

define abs (u[]) {
    if (u[0] > 0) return u[k]
    if (u[0] < 0) return - u[k]
    return 1 / 0
}
 
define mul (u[], v[]) {
    auto j, p
    for (j = 0; j <= k; j++) p += u[j] * v[k - j]
    return p
}
 
define exp (exp[], u[]) {
    auto j, e
    if (k == 0) return e(u[k])
    for (j = 0; j < k; j++) e += exp[j] * (k - j) * u[k - j]
    return e / k
}

define sin (cos[], u[]) {
    auto j, s
    if (k == 0) return s(u[k])
    for (j = 0; j < k; j++) s += cos[j] * (k - j) * u[k - j]
    return s / k
}

define cos (sin[], u[]) {
    auto j, c
    if (k == 0) return c(u[k])
    for (j = 0; j < k; j++) c += sin[j] * (k - j) * u[k - j]
    return - c / k
}
 
define tanh (sech2[], u[]) {
    auto j, th
    if (k == 0) return (e(2 * u[k]) - 1) / (e(2 * u[k]) + 1)
    for (j = 0; j < k; j++) th += sech2[j] * (k - j) * u[k - j]
    return th / k
}

define sech2 (tanh[], u[]) {
    auto j, sh2
    if (k == 0) return 1 - tanh[k] * tanh[k]
    for (j = 0; j < k; j++) sh2 += tanh[j] * (k - j) * tanh[k - j]
    return - 2 * sh2 / k
}
